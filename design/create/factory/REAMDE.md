## 简单工厂(重要)
> 由一个工厂对象决定创建出哪一种产品类的实例

**适用场景**(通过传参获取对象)
- 工厂类负责创建的对象比较少
- 客户端只知道传入工厂类的参数,对于如果创建对象不关心

**优点**
- 只需要传一个正确的参数来获取指定的对象,而无需知道其他创建细节

**缺点**
- 工厂类职责相对过重,增加新的产品需要修改工厂类的判断逻辑,违背开闭原则

**源码使用点**
- Calendar的创建



## 工厂方法(重要)
> 定义一个创建对象的接口,但让实现这个接口的类来决定实例化那个类
> 工厂方法让类的实例化延迟到子类中进行


**适用场景**
- 创建对象需要大量重复的代码
- 客户端不依赖产品类实现如何被创建、实现等细节
- 一个类通过其子类来指定创建那个对象

**优点**
- 用户只需要关心所需产品对应的工程,无需关心创建细节
- 加入新产品,符合开闭原则

**缺点**
- 类的个数容易过多,增加负责度
- 增加系统复杂度和理解难度

**源码使用点**
- Collection的iterator方法


## 抽象方法(重要)
> 抽象工厂模式提供一个创建一系列相关或者相互依赖对象的接口
> 无需指定它们具体的类


**适用场景**
- 客户端不依赖产品类实现如何被创建、实现等细节
- 强调一系列相关的产品对象(同一产品族)一起使用创建对象需要大量重复代码
- 提供一个产品类的库,所有产品以同样的接口出现,从而使客户端不依赖于具体实现

**优点**
- 具体产品在应用层代码隔离, 无需关心创建细节
- 将一个系列的产品族统一到一起创建

**缺点**
- 规定了所有可能被创建的产品集合,产品族中扩展新的产品困难,需要修改抽象工厂的接口
- 增加了系统的复杂度和理解难度

**产品等级和产品族**
- 产品等级: 指同类的物品,对象(美的、格力都是空调)
- 产品族: 指不是同一类物品 (美的分洗衣机,空调，电冰箱)

##总结
简单工厂  一般指通过指定参数获取少量对象
工厂方法 一般针对的是产品等级结构
抽象工厂 一般针对的是产品族

